<!DOCTYPE html>
<html lang="en">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<title>

  Anko DSL vs Android XML-First · Máximo Mussini

</title>
<meta name="author" content="Máximo Mussini">
<meta name="description" content="">
<meta name="keywords" content="">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="cleartype" content="on">

<!-- Styles -->
<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Raleway:700,800,900|Lato:300,300italic,400,400italic,700,900" type="text/css">
<link rel="stylesheet" href="/assets/css/styles.css" media="screen, projection">

<!-- Icons -->
<link rel="shortcut icon" href="/favicon.ico">
<link rel="apple-touch-icon" href="/apple-touch-icon.jpg">
<link rel="alternate" type="application/atom+xml" href="/feed.xml" title="Máximo Mussini · Code and Design">

<!-- Facebook Stuff -->
<meta property="og:type" content="website">
<meta property="og:locale" content="en_US">
<meta property="og:url" content="http://maximomussini.com/posts/anko-vs-android-xml/">
<meta property="og:site_name" content="Máximo Mussini">
<meta property="og:title" content="Anko DSL vs Android XML-First">
<meta property="og:image" content="http://maximomussini.com/images/posts/anko-vs-android-xml.jpg">
<meta property="og:description" content="Anko is a library for Android development in Kotlin. The library provides helper methods that take advantage of Kotlin’s extension functions as a way to reduce the amount of boilerplate the Android SDK requires. Those extension functions make it possible to accomplish common tasks like starting an activity or displaying a toast in a very succinct way.

A big part of…">

<!-- Twitter Stuff -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:domain" value="maximomussini.com" />
<meta name="twitter:title" value="Anko DSL vs Android XML-First" />
<meta name="twitter:description" value="Anko is a library for Android development in Kotlin. The library provides helper methods that take advantage of Kotlin’s extension functions as a way to reduce the amount of boilerplate the Android SDK requires. Those extension functions make it possible to accomplish common tasks like starting an activity or displaying a toast in a very succinct way.

A big part of…" />
<meta name="twitter:image" content="http://maximomussini.com/images/posts/anko-vs-android-xml.jpg" />
<meta name="twitter:url" value="http://maximomussini.com/posts/anko-vs-android-xml/" />

  <body>
    <header>
  
    <div class="hero" style="background-image: url(/images/posts/anko-vs-android-xml.jpg)">
      <h1>Anko DSL vs Android XML-First</h1>
    </div>
  
</header>

    <div class="menu container">
  <ul>
    
<li>
  <a href="/about/">About</a>
</li>

    
<li>
  <a href="/posts/">Posts</a>
</li>

    <li>
      <a href="/" class="logo">
  <span class="text">M</span>
</a>

    </li>
    
<li>
  <a href="/projects/">Projects</a>
</li>

    
<li>
  <a href="/talks/">Talks</a>
</li>

  </ul>
  <hr />
</div>

    <div class="content container">
  

  <div class="post-info">
  <span class="date">January 04, 2016</span>
  <span class="reading-time">5 min read</span>
</div>


  <div class="post">
    <p><a href="https://github.com/kotlin/anko"><em>Anko</em></a> is a library for <em>Android</em> development in <a href="https://kotlinlang.org"><em>Kotlin</em></a>. The library provides helper methods that take advantage of <em>Kotlin</em>’s extension functions as a way to reduce the amount of boilerplate the <em>Android SDK</em> requires. Those extension functions make it possible to accomplish common tasks like starting an activity or displaying a toast in a very succinct way.</p>

<p>A big part of the library though, focuses on creating a <a href="https://kotlinlang.org/docs/reference/type-safe-builders.html">type-safe builder</a> for creating view hierarchies, as an alternative to the XML-inflated view approach. Some of the benefits of defining a layout with <em>Anko</em> are type-safety, and efficiency, since it’s not necessary to parse the XML.</p>

<p>I decided to take the DSL for a test drive by rewriting the “Navigation Drawer Activity” template from <em>AndroidStudio</em>, replacing some of the XML layouts with the <em>Anko DSL</em>.</p>

<p><img src="/images/posts/anko-vs-android-xml/navigation-drawer-activity-template.png" alt="Alt" class="" /></p>

<p>We can define an <code class="highlighter-rouge">AnkoComponent</code> to create the UI:</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin">package com.maximomussini.anko

import android.support.design.widget.AppBarLayout
import android.support.design.widget.Snackbar
import android.support.v4.content.ContextCompat
import android.support.v4.view.GravityCompat
import android.util.TypedValue
import android.view.Gravity
import android.view.View
import com.maximomussini.anko.util.snackbar
import org.jetbrains.anko.*
import org.jetbrains.anko.appcompat.v7.toolbar
import org.jetbrains.anko.design.appBarLayout
import org.jetbrains.anko.design.coordinatorLayout
import org.jetbrains.anko.design.floatingActionButton
import org.jetbrains.anko.design.navigationView
import org.jetbrains.anko.support.v4._DrawerLayout
import org.jetbrains.anko.support.v4.drawerLayout

class MainUI : AnkoComponent&lt;MainActivity&gt; {

    override fun createView(ui: AnkoContext&lt;MainActivity&gt;): View = with(ui) {
        drawerLayout {
            id = R.id.drawer
            fitsSystemWindows = true
            createAppBar(ui)
            createNavigationView(ui)
        }
    }

    fun _DrawerLayout.createAppBar(ui: AnkoContext&lt;MainActivity&gt;) {
        coordinatorLayout {
            fitsSystemWindows = true

            appBarLayout {
                toolbar {
                    id = R.id.toolbar
                    popupTheme = R.style.AppTheme_PopupOverlay
                    backgroundResource = R.color.colorPrimary
                }.lparams(width = matchParent) {
                    val tv = TypedValue()
                    if (ui.owner.theme.resolveAttribute(R.attr.actionBarSize, tv, true)) {
                        height = TypedValue.complexToDimensionPixelSize(tv.data, resources.displayMetrics);
                    }
                }
            }.lparams(width = matchParent)

            relativeLayout {
                horizontalPadding = resources.getDimensionPixelSize(R.dimen.activity_horizontal_margin)
                verticalPadding = resources.getDimensionPixelSize(R.dimen.activity_vertical_margin)
                textView("Hello World!")
            }.lparams(width = matchParent, height = matchParent) {
                behavior = AppBarLayout.ScrollingViewBehavior()
            }

            floatingActionButton {
                imageResource = android.R.drawable.ic_dialog_email
                backgroundColor = ContextCompat.getColor(ui.owner, R.color.colorAccent)
                onClick {
                    snackbar("Replace with your own action", Snackbar.LENGTH_LONG) {
                        setAction("Action") { ui.toast("Clicked Snack") }
                    }
                }
            }.lparams {
                margin = resources.getDimensionPixelSize(R.dimen.fab_margin)
                gravity = Gravity.BOTTOM or GravityCompat.END
            }
        }.lparams(width = matchParent, height = matchParent)
    }

    fun _DrawerLayout.createNavigationView(ui: AnkoContext&lt;MainActivity&gt;) {
        navigationView {
            fitsSystemWindows = true
            setNavigationItemSelectedListener(ui.owner)
            inflateHeaderView(R.layout.nav_header_main)
            inflateMenu(R.menu.activity_main_drawer)
        }.lparams(height = matchParent, gravity = GravityCompat.START)
    }
}</code></pre></figure>

<p>And then, use the component to set the content view for the activity instead of using an XML layout:</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin">package com.maximomussini.anko

import android.os.Bundle
import android.support.design.widget.NavigationView
import android.support.v4.view.GravityCompat
import android.support.v4.widget.DrawerLayout
import android.support.v7.app.ActionBarDrawerToggle
import android.support.v7.app.AppCompatActivity
import android.support.v7.widget.Toolbar
import android.view.Menu
import android.view.MenuItem
import org.jetbrains.anko.find
import org.jetbrains.anko.setContentView
import org.jetbrains.anko.toast

class MainActivity : AppCompatActivity(), NavigationView.OnNavigationItemSelectedListener {

    lateinit var drawer: DrawerLayout

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        MainUI().setContentView(this)
        drawer = find&lt;DrawerLayout&gt;(R.id.drawer)

        val toolbar = find&lt;Toolbar&gt;(R.id.toolbar)
        setSupportActionBar(toolbar)

        val toggle = ActionBarDrawerToggle(this, drawer, toolbar,
                R.string.navigation_drawer_open, R.string.navigation_drawer_close)
        drawer.setDrawerListener(toggle)
        toggle.syncState()
    }

    override fun onBackPressed() {
        if (drawer.isDrawerOpen(GravityCompat.START)) {
            drawer.closeDrawer(GravityCompat.START)
        } else {
            super.onBackPressed()
        }
    }

    override fun onCreateOptionsMenu(menu: Menu): Boolean {
        menuInflater.inflate(R.menu.main, menu)
        return true
    }

    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        when (item.itemId) {
            R.id.action_settings -&gt; {
                toast("Settings")
                return true
            }
        }
        return super.onOptionsItemSelected(item)
    }

    override fun onNavigationItemSelected(item: MenuItem): Boolean {
        when (item.itemId) {
            R.id.nav_camera -&gt; toast("Camera")
            R.id.nav_gallery -&gt; toast("Gallery")
            R.id.nav_slideshow -&gt; toast("Slideshow")
            R.id.nav_manage -&gt; toast("Manage")
            R.id.nav_share -&gt; toast("Share")
            R.id.nav_send -&gt; toast("Send")
        }
        drawer.closeDrawer(GravityCompat.START)
        return true
    }
}</code></pre></figure>

<p>In contrast with the <a href="https://gist.github.com/ElMassimo/839df056c44b7c8e53b7">generated version</a>, the <em>Anko</em> version does require some boilerplate to set dimensions and colors from resources, but has a lot of expressiveness when it comes to bindings. Notice how it’s not necessary to create references to most of the components, since the listeners are added to each view when they are instantiated:</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin">floatingActionButton {
    onClick { snackbar("FAB", Snackbar.LENGTH_LONG) }
}</code></pre></figure>

<p>Compare this to the usual code, which incurs in the cost of finding the view (even if it’s a very low cost) and referencing the view id:</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin">val fab:FloatingActionButton = findViewById(R.id.fab) as FloatingActionButton
fab.setOnClickListener {
  Snackbar.make(it, "FAB", Snackbar.LENGTH_LONG).show()
}</code></pre></figure>

<p>The <em>Anko DSL</em> exposes the native API of each View, so it’s only possible to do what <em>Android</em> components can do, with the exception of a few synthetic properties to set text or an image from a resource.</p>

<p>Unfortunately, that means things get pretty rough once we dive into styling and theming. The <em>Android SDK</em> and support libraries contain a lot of <em>hacks</em> that rely on the view being created by a <code class="highlighter-rouge">LayoutInflater</code> from the XML, initializing the view with a <code class="highlighter-rouge">Context</code> and an <code class="highlighter-rouge">AttributeSet</code>. There’s no first-class support for setting the <a href="https://github.com/Kotlin/anko/issues/16">style</a> or theme programmatically, which means it’s not possible to set them when using <em>Anko</em> either.</p>

<p><em>Anko</em> does provide a way to <a href="https://github.com/Kotlin/anko#styles">style a view</a>, but it leaves much to be desired since it requires targeting the different view classes manually, unlike styling in XML where valid attributes are applied automatically.</p>

<p>When it comes to theming, <em>Android</em> uses <a href="http://chris.banes.me/2014/11/12/theme-vs-style/#underlying-functionality"><code class="highlighter-rouge">ContextThemeWrapper</code></a> internally to override <code class="highlighter-rouge">getTheme</code> for a view or its children. Since the <a href="https://github.com/Kotlin/anko/releases/tag/v0.8.1">current <em>Anko</em> version</a> does not allow to override the context used to create a view inside the DSL, using a theme-wrapped context manually is extremely contrived.</p>

<p>No theming support is a serious limitation, since most components in the design library need a theme to be styled properly.</p>

<p><img src="/images/posts/anko-vs-android-xml/anko-vs-xml.png" alt="Anko does not have theming support" class="square" /></p>

<p>It should be possible to add support for theming in <em>Anko</em>, but unfortunately theming is just one of many XML-based hacks and workarounds in the SDK.</p>

<p>Adding views with Java code is very cumbersome, so most Java developers will stick to XML, and the SDK and support library will continue to do hacks around XML inflation.</p>

<p>The idea behind the <em>Anko DSL</em> is a very interesting one, but it seems like the <em>Android SDK</em> is not polished enough for <em>Anko</em> to reach its full potential.</p>

  </div>

  <div class="ending">
  <div class="author">
    <a href="/" class="logo">
  <span class="text">M</span>
</a>

    By
    <a href="https://twitter.com/MaximoMussini" class="author-name short">@Maximo</a>
    <a href="https://twitter.com/MaximoMussini" class="author-name full">@MaximoMussini</a>
    <a href="https://twitter.com/share" class="twitter-share-button" data-via="MaximoMussini" data-dnt="true">Tweet</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  </div>
</div>

</div>



  <a id="next-post" href="/posts/rails-ajax_redirect/" class="hidden"></a>




  <div class="previous-post">
    <div class="content container">
      <a id="previous-post" href="/posts/coffeescript-js-libraries/" class="overlay">
        <h1>CoffeeScript and JS Libraries</h1>
        <div class="post-info">
  <span class="date">December 31, 2015</span>
  <span class="reading-time">3 min read</span>
</div>

        <div class="post">
          <p>A language helps to shape the libraries that are written on it. This can have unexpected side-effects when using these libraries from a different language.</p>

<p>In the frontend this has become increasingly more common because of all the available languages that compile to JavaScript. <span href="http://coffeescript.org/"><em>CoffeeScript</em></span> was one of the first ones to gain adoption, but nowadays we have a myriad of available languages like <span href="http://elm-lang.org/"><em>Elm</em></span>, …</p>
        </div>
      </a>
    </div>
  </div>



    <script>
if (document.location.hostname.search('maximomussini.com') !== -1) {
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-67510525-1', 'auto');
  ga('send', 'pageview');
}
</script>

<script src="/assets/js/anchors.js"></script>
<script src="/assets/js/shortcuts.js"></script>

  </body>
</html>
